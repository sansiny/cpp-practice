### 一、模板类别

​	数据结构：可持久化 `FHQTreap` 树（可持久化无旋 `treap` ）。

### 二、模板功能

#### 1.建立平衡树

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树中编号、子树大小的变量类型。

   类型设定 `priority_type = uint32_t` ，表示树中结点的随机权重的变量类型。

   模板参数 `typename Tp` ，表示树中的键类型。

   模板参数 `typename Node` ，表示树中的结点结构体类型，默认为 `OY::PersistentTreap::BaseNode<Tp>` 。

   模板参数 `typename Compare` ，表示比较函数的类型，默认为 `std::less<Tp>` 。

   模板参数 `size_type MAX_NODE` ，表示最大结点数，默认为 `1<<19` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   **注意：** 以下内容中注意**连接**和**合并**的不同。连接表示两棵树值域不相交，前树的最大值小于（等于）后树的最小值，这种情况下的树的融合。合并表示两棵树值域可能相交的情况下的树的融合。在代码中，我称连接为 `join` ，称合并为 `merge` 。

   对于算法比赛来说，平衡二叉树可以有多种备选类型。接下来我们从多个方面进行分析：

   1. 论速度，应以 `RBT` ， `AVL` ， `SBT` 的速度最快，同为第一梯队。而替罪羊树、 `splay` 、有旋 `treap` 、无旋 `treap` 依次排在之后。然而，最快的和最慢的树，速度也达不到两倍，实现良好的无旋 `treap` 速度甚至可以反超标准库的 `RBT` ，这表明各种树的速度影响程度并不大。
   2. 论形态，只有 `splay` 的树形态会特别失衡，其他树的树高都会维持在对数高度。这表明 `splay` 难以进行可持久化，且难以进行细微的树中自由操作，很容易时间复杂度超标。
   3. 论功能，只有 `splay` 和无旋 `treap` 支持对数时间复杂度的分裂和连接。在启发式合并任务中，`splay` 和无旋 `treap` 的时间复杂度为 $O(n\log n)$ ，而其余平衡二叉树的时间复杂度为 $O(n\log^2 n)$ 。

   综上所述，无旋 `treap` 是最适合算法比赛的平衡二叉树模板，也是最适合算法比赛的可持久化平衡二叉树模板。

   本模板与 `OY::FHQTreap` 模板高度重合，仅有的几处不同为：

   1. 提供了拷贝结点的静态方法；
   2. 在执行 `pushdown` 之前，会进行孩子结点的拷贝；
   3. 删除了 `clear` 方法（因为无法判断一棵树是否和其他树共享枝干）；
   4. 提供了 `copy` 方法。

   所以只要熟悉 `OY::FHQTreap` 模板，就可以零成本学习本模板。

   本模板类名为 `Multiset` ，即可重集合。如果想实现去重集合的功能，应当在插入元素前进行元素有无的判断。

   模板参数 `Node` 类型必须包含一个名为 `m_val` 的 `Tp` 类型的成员变量，除此之外可以自定义别的变量。当需要提供区间修改功能时， `Node` 类型须添加 `pushdown` 方法；当需要提供区间查询功能时， `Node` 类型须添加 `pushup` 方法；如果只想使用名次树，使用默认的 `OY::PersistentTreap::BaseNode<Tp>` 即可。

#### 2.拷贝(copy)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在可持久化数据结构中，一棵树的拷贝就是其根节点的拷贝。至于子孙结点，并不需要即时全部拷贝，等到之后进行访问的时候，才会逐个进行拷贝。


#### 3.根据值插入(insert_by_val)

1. 数据类型：

   参数 `const Tp &val`​ ，表示要插入的值。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法按照二叉搜索树的规则，在树中插入一个新元素。

   如果树中已有同值的元素，新插入的元素会排在后面。

#### 4.根据位置插入(insert_by_rank)

1. 数据类型：

   参数 `const Tp &val`​ ，表示要插入的值。

   参数 `size_type k` ，表示要插入的位置下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法在树中插入一个新元素，使其成为中序遍历的 `k` 号元素。

   下标 `k` 基于 `0` ，取值范围为 `[0, size()]` 。

#### 5.根据值插入结点(insert_node_by_val)

1. 数据类型：

   参数 `node *x`​ ，表示要插入的结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法按照二叉搜索树的规则，在树中插入一个新元素。

   如果树中已有同值的元素，新插入的元素会排在后面。

   **注意：**本方法与 `insert_by_val` 方法作用相同，适用于想对结点的属性进行一些自定义初始化的情况。结点可以通过 `Multiset::_create` 方法获取，在修改属性之后进行 `insert_node_by_val` 。

#### 6.根据位置插入结点(insert_node_by_rank)

1. 数据类型：

   参数 `node *x`​ ，表示要插入的结点。

   参数 `size_type k` ，表示要插入的位置下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法在树中插入一个新元素，使其成为中序遍历的 `k` 号元素。

   下标 `k` 基于 `0` ，取值范围为 `[0, size()]` 。

   **注意：**本方法与 `insert_by_rank` 方法作用相同，适用于想对结点的属性进行一些自定义初始化的情况。结点可以通过 `Multiset::_create` 方法获取，在修改属性之后进行 `insert_node_by_rank` 。

#### 7.根据值删除(erase_by_val)

1. 数据类型：

   参数 `const Tp &val`​ ，表示要删除的值。

   返回类型 `bool` ，表示是否删除元素。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法按照二叉搜索树的规则，在树中找到并删除一个元素。

   如果找不到相应的元素，返回 `false` 。

#### 8.根据位置删除(erase_by_rank)

1. 数据类型：

   参数 `size_type k`​ ，表示要删除的位置下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法删除树的中序遍历的 `k` 号元素。

   下标 `k` 基于 `0` ，取值范围为 `[0, size()-1]` 。

#### 9.根据值修改结点(modify_by_val)

1. 数据类型：

   参数 `const Tp &val`​ ，表示要修改的结点的值。

   参数 `Modify modify` ，表示要对结点进行的修改。建议传递匿名函数。

   返回类型 `bool` ，表示是否修改结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法按照二叉搜索树的规则，在树中找到并修改一个结点。

   如果找不到相应的元素，返回 `false` 。

   一般而言，本方法是对 `m_val` 之外的属性进行修改， `m_val` 本身作为排序的依据不应被修改。

#### 10.根据位置修改结点(modify_by_rank)

1. 数据类型：

   参数 `size_type k`​ ，表示要删除的位置下标。

   参数 `Modify modify` ，表示要对结点进行的修改。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法找到树的中序遍历的 `k` 号元素并进行修改。

   下标 `k` 基于 `0` ，取值范围为 `[0, size()-1]` 。

#### 11.根据值分裂(split_by_val)

1. 数据类型

   参数 `const Tp &val` ，表示进行分裂处的值。

   返回类型 `Multiset` ，表示分裂得到的新树。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法在原树中保留小于 `val` 的元素，将所有大于等于 `val` 的元素分裂到新树中。

#### 12.根据位置分裂(split_by_rank)

1. 数据类型

   参数 `size_type k` ，表示进行分裂处的位置下标。

   返回类型 `Multiset` ，表示分裂得到的新树。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法将原树中序遍历的 `k` 号之间的元素保留，将 `k` 号及之后的元素分裂到新树中。

   下标 `k` 基于 `0` ，取值范围为 `[0, size()]` 。

#### 13.连接另一棵树(join)

1. 数据类型

   参数 `Multiset &other` ，表示要连接的树。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法要求本树与要连接的树的值域范围不存在交叉；即，先进行本树的中序遍历，再进行要连接的树的中序遍历，所得序列不降。

   连接后， `other` 被清空。

#### 14.合并另一棵树(merge)

1. 数据类型

   参数 `Multiset &other` ，表示要合并的树。

   参数 `Func func` ，表示对同样键值的结点的处理方式，默认为 `Ignore` 。

2. 时间复杂度

    $O(n)$ 。

3. 备注

   本方法对值域范围无要求。

   合并后， `other` 被清空。

   如果树中允许重复键值，参数 `func` 为默认的 `Ignore` ，不会对两棵树里的相同键值的结点采取特殊处理，而是统统合并到一颗树里。

   如果树中不允许重复键值，参数 `func` 需要传递一个函数，对两棵树里的相同键值的结点采取特殊处理，然后只保留其中的一个。

#### 15.获取根结点(root)

1. 数据类型

   返回类型 `node*` ，表示根结点。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   返回的结点 `x` 可以通过 `x->is_null()` 判断是否为空结点；空树时返回空结点。

   **注意：**返回的空结点并不是 `nullptr` 。

#### 16.获取树大小(size)

1. 数据类型

   返回类型 size_type，表示树大小。

2. 时间复杂度

   $O(1)$ 。

#### 17.根据位置获取结点(kth)

1. 数据类型

   输入参数 `size_type k` ，表示要获取的结点的位置下标。

   返回类型 `node*` ，表示获取的结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   请勿通过本方法获取结点，然后对结点的属性进行修改。这样的修改不能一层一层自动 `pushup` 。

#### 18.获取某值的排名(rank)

1. 数据类型

   输入参数 `const Tp &val` ，表示值。

   返回类型 `size_type` ，表示值对应的排名。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   返回的排名基于 `0` ，取值范围为 `[0, size()]` 。

#### 19.根据值获取前驱结点(smaller_bound)

1. 数据类型

   输入参数 `const Tp &val` ，表示值。

   返回类型 `node*` ，表示获取的结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   请勿通过本方法获取结点，然后对结点的属性进行修改。这样的修改不能一层一层自动 `pushup` 。

   返回的结点 `x` 可以通过 `x->is_null()` 判断是否为空结点；若无前驱结点，返回空结点。

   **注意：**返回的空结点并不是 `nullptr` 。

#### 20.根据值获取lower_bound(lower_bound)

1. 数据类型

   输入参数 `const Tp &val` ，表示值。

   返回类型 `node*` ，表示获取的结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   请勿通过本方法获取结点，然后对结点的属性进行修改。这样的修改不能一层一层自动 `pushup` 。

   返回的结点 `x` 可以通过 `x->is_null()` 判断是否为空结点；若无相应结点，返回空结点。

   **注意：**返回的空结点并不是 `nullptr` 。

#### 21.根据值获取upper_bound(upper_bound)

1. 数据类型

   输入参数 `const Tp &val` ，表示值。

   返回类型 `node*` ，表示获取的结点。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   请勿通过本方法获取结点，然后对结点的属性进行修改。这样的修改不能一层一层自动 `pushup` 。

   返回的结点 `x` 可以通过 `x->is_null()` 判断是否为空结点；若无相应结点，返回空结点。

   **注意：**返回的空结点并不是 `nullptr` 。

### 三、模板示例

```c++
#include "DS/PersistentFHQTreap.h"
#include "IO/FastIO.h"

/*
 * 可持久化 FHQTreap 绝大多数方法，使用方式都和普通 FHQTreap 版本相同
 * 结点的 pushdown 和 pushup ，也和 普通 FHQTreap 版本相同
 * 注意，在生成新版本的树时，请先对旧树拷贝，再对新树进行操作。
 */

/*
 * 可持久化 FHQTreap 可以在进行树上操作时，保留旧版本的树的信息
 */
void test() {
    cout << "test of persistent treap:\n";
    std::vector<OY::PersistentFHQTreap::Multiset<int>> Trees;
    Trees.push_back({});
    for (int value = 1; value < 20; value += 2) {
        Trees.push_back(Trees.back().copy());
        Trees.back().insert_by_val(value);
    }
    for (int value = 2; value < 20; value += 2) {
        Trees.push_back(Trees.back().copy());
        Trees.back().insert_by_val(value);
    }
    for (int value = 1; value < 20; value += 5) {
        Trees.push_back(Trees.back().copy());
        Trees.back().erase_by_val(value);
    }

    // 此时可以看到所有的操作痕迹
    for (int i = 0; i < Trees.size(); i++) {
        cout << Trees[i] << '\n';
    }
}

int main() {
    test();
}
```

```
#输出如下
test of persistent treap:
{}
{1}
{1, 3}
{1, 3, 5}
{1, 3, 5, 7}
{1, 3, 5, 7, 9}
{1, 3, 5, 7, 9, 11}
{1, 3, 5, 7, 9, 11, 13}
{1, 3, 5, 7, 9, 11, 13, 15}
{1, 3, 5, 7, 9, 11, 13, 15, 17}
{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}
{1, 2, 3, 5, 7, 9, 11, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 7, 9, 11, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19}
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}
{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}
{2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}
{2, 3, 4, 5, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19}
{2, 3, 4, 5, 7, 8, 9, 10, 12, 13, 14, 15, 17, 18, 19}

```

